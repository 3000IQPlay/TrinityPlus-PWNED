//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\charl\Downloads\Minecraft-Deobfuscator3000-master\1.12 stable mappings"!

//Decompiled by Procyon!

package me.leon.trinityplus.hacks.exploits;

import me.leon.trinityplus.setting.rewrite.*;
import me.zero.alpine.fork.listener.*;
import me.leon.trinityplus.events.main.*;
import me.leon.trinityplus.hacks.*;
import me.leon.trinityplus.utils.misc.*;
import net.minecraft.network.play.client.*;
import java.util.function.*;
import net.minecraft.network.play.server.*;
import net.minecraft.network.*;
import java.math.*;

public class PacketLogger extends Module
{
    public static final BooleanSetting timer;
    public static final SliderSetting timerAmount;
    public static final BooleanSetting in;
    public static final BooleanSetting out;
    public static final BooleanSetting cposition;
    public static final BooleanSetting cconfirm;
    private int packets;
    private long time;
    @EventHandler
    private final Listener<EventPacketSend> onPacketSend;
    @EventHandler
    private final Listener<EventPacketRecieve> onPacketReceive;
    
    @Override
    public String getHudInfo() {
        return String.valueOf(this.packets);
    }
    
    public PacketLogger() {
        super("PacketLogger", "Logs packets", Category.EXPLOITS);
        this.time = 0L;
        Packet event_p;
        CPacketConfirmTeleport packet;
        CPacketPlayer packet2;
        double x;
        double y;
        double z;
        String message;
        this.onPacketSend = new Listener<EventPacketSend>(event -> {
            if (!PacketLogger.out.getValue()) {
                return;
            }
            else {
                event_p = event.getPacket();
                if (event_p instanceof CPacketConfirmTeleport && PacketLogger.cconfirm.getValue()) {
                    packet = (CPacketConfirmTeleport)event_p;
                    MessageUtil.sendClientMessage("Confirm: [ " + packet.getTeleportId() + " ]", true);
                    ++this.packets;
                }
                else if (event_p instanceof CPacketPlayer && PacketLogger.cposition.getValue()) {
                    packet2 = (CPacketPlayer)event_p;
                    if (packet2.moving) {
                        x = this.roundToPlace(packet2.x, 2);
                        y = this.roundToPlace(packet2.y, 2);
                        z = this.roundToPlace(packet2.z, 2);
                        message = String.format("Pos: [%s, %s, %s] [ %b ]", x, y, z, packet2.onGround);
                        MessageUtil.sendClientMessage(message, true);
                        ++this.packets;
                    }
                }
                if (this.packets == (int)PacketLogger.timerAmount.getValue()) {
                    MessageUtil.sendClientMessage(this.packets + " packets has been sent. " + (System.currentTimeMillis() - this.time) + " millis has passed.", true);
                    this.time = System.currentTimeMillis();
                    this.packets = 0;
                }
                return;
            }
        }, (Predicate<EventPacketSend>[])new Predicate[0]);
        Packet event_p2;
        SPacketPlayerPosLook packet3;
        double x2;
        double y2;
        double z2;
        String message2;
        this.onPacketReceive = new Listener<EventPacketRecieve>(event -> {
            if (!(!PacketLogger.in.getValue())) {
                event_p2 = event.getPacket();
                if (event_p2 instanceof SPacketPlayerPosLook && PacketLogger.cconfirm.getValue()) {
                    packet3 = (SPacketPlayerPosLook)event_p2;
                    x2 = this.roundToPlace(packet3.x, 2);
                    y2 = this.roundToPlace(packet3.y, 2);
                    z2 = this.roundToPlace(packet3.z, 2);
                    message2 = String.format("[S] Pos: [%s, %s, %s]", x2, y2, z2);
                    MessageUtil.sendClientMessage("[S] Confirm: [ " + packet3.getTeleportId() + " ]", true);
                    MessageUtil.sendClientMessage(message2, true);
                }
            }
        }, (Predicate<EventPacketRecieve>[])new Predicate[0]);
    }
    
    private double roundToPlace(final double value, final int places) {
        if (places < 0) {
            throw new IllegalArgumentException();
        }
        BigDecimal bd = new BigDecimal(value);
        bd = bd.setScale(places, RoundingMode.HALF_UP);
        return bd.doubleValue();
    }
    
    static {
        timer = new BooleanSetting("Timer", true);
        timerAmount = new SliderSetting("TimerAmount", 0.0, 60.0, 100.0, true);
        in = new BooleanSetting("In", true, true);
        out = new BooleanSetting("Out", true, true);
        cposition = new BooleanSetting("CPacketPlayerPosition", PacketLogger.out, true);
        cconfirm = new BooleanSetting("CPacketConfirmTeleport", PacketLogger.out, true);
    }
}
